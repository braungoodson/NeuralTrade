module.exports = function (PID,PORT,BUYIN,CASH,BTC,CHIP,FUTURE) {

	var h = require('https');
	var N = require('brain').NeuralNetwork;

	var ticker;
	var tickers = [];
	var trainingData = [];
	var predictions = [];
	var buyIn = BUYIN;
	var cash = CASH;
	var btc = BTC;
	var profit = 0;
	var rate = 0;
	var prediction;
	var chip = CHIP;
	var fee = .0025;
	var n = new N();
	var o;

	predictions.push({});

	function _process(_) {
		console.log(_);
	}

	function buy(r) {
		var cost = ((r * chip) + fee);
		if (cost <= cash) {
			cash = cash - cost;
			btc = btc + chip;
		}
	}

	function sell(r) {
		var sale = (fee + (chip * r));
		if (btc >= chip) {
			cash = cash + sale;
			btc = btc - chip;
		}
	}

	function stay() {
		return null;
	}

	function chooseDestiny(a,b,buyRate,sellRate) {
		if (a.buy > b.buy) {
			buy(buyRate);
			prediction = 'buy';
		} else if (a.buy < b.buy) {
			sell(sellRate);
			prediction = 'sell';
		} else {
			stay();
			prediction = 'stay';
		}
	}

	function callback(d) {
		trainingData.push(d[1]);
		n.train(trainingData);
		o = {
			date: (tickers[tickers.length-1] + FUTURE) * .00000000001
		};
		predictions.push(n.run(o));
		rate = ((d[0].sell+d[0].buy)/2);
		chooseDestiny(
			predictions[predictions.length-1],
			predictions[predictions.length-2],
			d[0].sell,
			d[0].buy
		);
		profit = (((btc * d[0].sell) + cash) - buyIn);
	}

	function process(p) {
		callback(p);
	}

	function parse(d) {
		ticker = d.ticker;
		tickers.push(d.ticker);
		var x = .000001;
		var y = .0000000001;
		var z = .00000000001;
		var i = {
			date: d.ticker.updated * z
		};
		var o = {
			buy: d.ticker.buy * x,
			sell: d.ticker.sell * x,
			high: d.ticker.high * x,
			low: d.ticker.low * x,
			avg: d.ticker.avg * x,
			vol: d.ticker.vol * y,
			vol_cur: d.ticker.vol_cur * y
		};
		return process([
			{buy:d.ticker.buy,sell:d.ticker.sell},
			{input:i,output:o}
		]);
	}

	function dump() {
		console.log('');
		console.log('          \033[32m$\033[0m '+cash);
		console.log('        \033[33mBTC\033[0m '+btc);
		console.log('     \033[34mProfit\033[0m '+profit);
		console.log('       \033[35mRate\033[0m '+rate);
		console.log(' \033[31mPrediction\033[0m '+prediction);
	}

	setInterval(function(){
		h.get('https://btc-e.com/api/2/btc_usd/ticker',function(r){
			var b = '';
			r.on('data',function(c){
				b += c;
			});
			r.on('end',function(d){
				try {
					var d = JSON.parse(b);
					parse(d);
				} catch (e) {
					console.log('\033[31m Could not parse feed: '+e+'\033[0m');
				}
				dump();
			});
		}).on('error',function(r){
			//
			console.log(' \033[31m Error: '+e);
		});
	},FUTURE);

	function chartData() {
		var labels = [];
		var datasets = [{
		  fillColor : "rgba(0,0,0,0.1)",
      strokeColor : "rgba(0,0,0,.5)",
      pointColor : "rgba(0,0,0,1)",
      pointStrokeColor : "#fff",
			data: []
		},{
			fillColor : "rgba(255,0,0,0.1)",
      strokeColor : "rgba(255,0,0,0.5)",
      pointColor : "rgba(255,0,0,0.5)",
      pointStrokeColor : "#fff",
			data: []
		}];
		var l;
		if (tickers.length < 10) {
			l = tickers.length;
		} else {
			l = 10;
		}
		var x = 10000;
		var b;
		for (var j = l; j > 0; --j) {
			labels.push(tickers[tickers.length-j].updated);
			a = (tickers[tickers.length-j].buy+tickers[tickers.length-j].sell)/2;
			a = parseFloat(a.toFixed(2));
			datasets[0].data.push(a);
			b = (((predictions[predictions.length-j].buy*x)+(predictions[predictions.length-j].sell*x))/2);
			b = b - (b * .1);
			b = parseFloat(b.toFixed(2));
			datasets[1].data.push(b);
		}
		var u,p,date;

		for (var i = 0; i < 10; i++) {
			date = tickers[tickers.length-1].updated + (i * 10000);
			labels.push(date);
			n.train(trainingData);
			p = n.run({
				date: date * .00000000001
			});
			b = ((p.buy+p.sell)/2)*x;
			b = b - (b * .1);
			b = parseFloat(b.toFixed(2));
			datasets[1].data.push(b);
		}

		return {
    	labels: labels,
      datasets: datasets
    };
	}

	var fs = require('fs');
	var appName = __dirname+'/app/index.html';
	var app;
	var users = [];
	users['braun'] = {name:'braun',password:'braun',data:null,getUser:function(){return{name:this.name,data:this.data}}};

	var mario = require('mario-mario');
	mario.plumbing({
		port: PORT,
		http: {
			get: {
				'/': function (q,r) {
					fs.readFile(appName,function(e,d){
				    if (e) {
				      console.log('\033[31mError reading file: %s\n\033[0m',e);
				      app = e;
				    } else {
				      app = d;
				    }
				    r.setHeader('Content-Type','text/html');
						return r.send(app);
				  });
				},
				'/ticker': function(q,r) {
					return r.send({ticker:ticker});
				},
				'/bot': function (q,r) {
						return r.send({
						cash: cash,
						btc: btc,
						profit: profit,
						rate: rate,
						prediction: prediction,
						pid: PID
					});
				},
				'/chartData': function(q,r) {
					return r.send({chartData:chartData()});
				}
			}
		}
	});
}